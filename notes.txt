0. x - set up react app w/ vite
1. x - set up vanilla node.js server
2. x - connect backend to frontend
3. x - nodemon
4. x - set up db and connect to backend (postgres - can do more, open source. mysql - simpler. companies prefer postgres i'd imagine)
5. x - frontend is connected to backend is connected to db (locally)
6. x - deploy and all is connected
7. x - identify entities for db, explain sql, then show data needed per screen in figma
8. x - play around w/ db then make script to populate it (first cmd is drop table)
9. x - build backend for front page w/o sequelize (actually write sql queries) and express (at least at first)
  - x - rewrite to use pg.Pool
    - x - https://node-postgres.com/apis/pool
    - x - https://chat.openai.com/?model=text-davinci-002-render-sha
  - x - first, vid explaining the queries in the design
  - x - then explain get, post (new entry), put (replace existing entry), delete, patch (modify PART OF existing entry)
  - x - comment the routes we need
  - x - make the routes
    - x - hyphen as word delimiter is preferred
    - x - show that vanilla node.js will get ugly, esp with dynamic routes
    - x - use express, benefits: 
      - x - easy org
      - x - plugin libraries (middleware)
    - x - postman - execute and test the routes, benefits:
      - x - collections (don't need to rewrite queries, organization)
      - x - visualize data
      - x - share and collab
    - error handling
10. break out routes into mvc
11. use sequelize instead of queries
  - define & implement db schemas (sequelize, mvc)
  - sequelize benefits - define relationships like oop, don't have to use sql except for more complicated queries
12. mention indexes for db
13. build the frontend (start w/ react router)
14. mention firebase / supabase and other options
  - pro - easy to get going
  - con - can get expensive once locked in and app scales
15. build auth
16. add logging
17. add swagger